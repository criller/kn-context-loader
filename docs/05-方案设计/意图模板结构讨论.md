# 意图模板结构讨论（MEC / cMEC / SEC / DebugEnvelope）

## 文档目标
- 用最小化与分层思路，重新梳理统一检索的意图模板结构，解决“模板过复杂”和“输出过多导致延迟”两点核心诉求。
- 明确：执行面只保留必要字段（最小执行契约），调试/解释面单独承载，不与执行契约混用。

## 设计原则（精简版）
- 执行优先：请求-响应只携带执行所需最小字段。
- 分层隔离：执行契约与调试包分离，互不污染。
- 版本可演进：以 Schema-first 管理，保持 v0.1.x 兼容，平滑升级。
- 轻量输出：默认不输出 `reasoning/metrics` 等长文本；必要时由服务端生成调试包，不由 LLM 输出。

## 四层结构总览
- MEC（Minimal Execution Contract，最小执行契约）：线上执行只需的字段集合，去除解释与度量。
- cMEC（Compact MEC，紧凑版）：LLM 输出的代号版（Codebook），工程侧解码成 MEC，最低 token 成本。
- SEC（Standard Execution Contract，标准扩展版）：在 MEC 基础上可选扩展（聚合/集合/路径/RAG），仍不含解释文本。
- DebugEnvelope（调试包）：承载 `reasoning/explain/metrics_estimate/trace_id`，用于离线评估与审计，不进入执行链路。

## MEC v0.2-lite（最小执行契约）

### 字段清单（必需与可选）
- `intent`
  - `scenario`：`instance_search | attributes_fetch | relation_query | relation_existence | path_query | subgraph | aggregation | set_ops | text_rag | clarify | hybrid`
  - `output_type`：`instances | relations | attributes | subgraph | texts | existence`
- `grounding`
  - 至少其一：`target_types[]` 或 `entity_list[]`
  - 可选：`relations[]`（类型+方向）、`target_attributes[]`
- `constraints`
  - `filters[]`（`field, operator, value?`）
  - `sort[]`（`field, order`）
  - `pagination{limit,offset}`（默认 `limit=20`）
- `graph_params`（仅在关系/路径/子图需要）：`direction | depth | relation_types[] | path?`

### 明确删除/不输出
- 不输出：`reasoning / explain / metrics_estimate / plan_hints / guardrails / confidence`（由路由与校验器内部使用，必要时写入调试包）。

### MEC 示例（实例检索）
```json
{
  "intent": {"scenario": "instance_search", "output_type": "instances"},
  "grounding": {"target_types": ["enterprise"], "entity_list": [{"text": "企业A"}]},
  "constraints": {
    "filters": [{"field": "enterprise.name", "operator": "contains", "value": "新能源"}],
    "sort": [{"field": "enterprise.created_at", "order": "desc"}],
    "pagination": {"limit": 20, "offset": 0}
  }
}
```

### MEC 示例（关系存在性）
```json
{
  "intent": {"scenario": "relation_existence", "output_type": "existence"},
  "grounding": {
    "entity_list": [{"text": "企业A"}, {"text": "园区B"}],
    "relations": [{"type": "enterprise_2_park", "direction": "out"}]
  },
  "constraints": {"filters": [], "sort": [], "pagination": {"limit": 1, "offset": 0}},
  "graph_params": {"direction": "out", "depth": 1, "relation_types": ["enterprise_2_park"]}
}
```

## cMEC c0.2（紧凑执行契约，Codebook）

### 代号表（示例）
- 场景 `s`：`IS | AF | RQ | REX | PQ | SG | AGG | SET | RAG | CL | HY`
- 输出 `o`：`INST | REL | ATTR | SUBG | TEXT | EXIST`
- 方向 `dir`：`O(out) | I(in) | B(both)`
- 操作符 `op`：`EQ | NE | CT | NC | SW | EW | LT | LE | GT | GE | IN | NI | BT | EX`
- 排序 `ord`：`A | D`
- 字段字典 `F{code -> "type.field"}`；关系字典 `R{code -> relation_type}`

### cMEC 示例（对应上面的 MEC）
```json
{
  "s": "IS",
  "o": "INST",
  "tg": ["enterprise"],
  "E": [{"txt": "企业A"}],
  "C": {
    "flt": [{"f": "F001", "op": "CT", "v": "新能源"}],
    "srt": [{"f": "F010", "ord": "D"}],
    "pg": {"lim": 20, "off": 0}
  },
  "G": {"dir": "O", "dep": 0, "rel": []}
}
```

### 解码与校验（工程侧）
- 仅接受注册代号；未知代号→拒绝或触发澄清。
- 展开 `Fxxx/Rxxx` 为标准字段与关系；对齐 TBox。
- 缺省填充：`pagination.limit`、`sort.order` 等；严格类型校验。
- 失败策略：字段不合法、集合过大或参数冲突→返回澄清问题，不将调试内容写回执行契约。

## SEC v0.2（标准扩展版，仍不含解释）
- 在 MEC 基础上允许：
  - `constraints.aggregation{metrics[], group_by[], having[], sort[], pagination}`
  - `constraints.set_ops{lhs, op, rhs}` 与 `constraints.groups[]`
  - `graph_params.path{source_ids?, target_types?, max_hops?, allowed_relations?}`
  - `rag_params{corpora[], top_k, rerank}`
- 以上均为结构化扩展，不包含 `reasoning/metrics` 文本。

## DebugEnvelope（调试包，仅离线/审计用）
- 字段：`trace_id | reasoning | explain | metrics_estimate | defaults_applied | guardrails | router_scores`
- 产生方式：由编排器/执行器服务端生成，不由 LLM 输出；与 MEC/SEC 关联通过 `trace_id`。
- 作用：回溯与评估，不参与线上执行与传输。

## 配置开关（服务端）
- `emit_reasoning`: 默认 `false`（只写入 DebugEnvelope）。
- `emit_metrics`: 默认 `false`。
- `emit_clarify`: 默认 `on` 仅在触发时返回澄清响应（单独响应类型）。
- `contract_version`: 默认 `v0.2-lite`；LLM 走 `c0.2`，解码到 MEC。

## JSON Schema（MEC 简化草案）
```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "MEC v0.2-lite",
  "type": "object",
  "required": ["intent", "grounding", "constraints"],
  "properties": {
    "intent": {
      "type": "object",
      "required": ["scenario", "output_type"],
      "properties": {
        "scenario": {"enum": ["instance_search","attributes_fetch","relation_query","relation_existence","path_query","subgraph","aggregation","set_ops","text_rag","clarify","hybrid"]},
        "output_type": {"enum": ["instances","relations","attributes","subgraph","texts","existence"]}
      }
    },
    "grounding": {"type": "object"},
    "constraints": {
      "type": "object",
      "properties": {
        "filters": {"type": "array"},
        "sort": {"type": "array"},
        "pagination": {"type": "object"}
      }
    },
    "graph_params": {"type": "object"}
  }
}
```

## 迁移与兼容
- v0.1.x → MEC：继续接受扁平 `constraints[]`，按字段映射到 `filters/sort/pagination`。
- 统一改造：LLM 改用 cMEC；服务接入解码器与校验器；DebugEnvelope 仅用于日志与评估。

## FAQ：关于 `reasoning` 字段
- 结论：`reasoning` 不属于执行契约（MEC/SEC）。
- 用途：仅用于回溯、解释与评估，放在 `DebugEnvelope`，由服务端生成，不由 LLM 输出。
- 好处：减少输出 token 与延迟，避免将长文本带入线上执行链路。

## 落地建议（两步）
- 第一步（本周）：落地 cMEC→MEC 解码器与校验器；关闭 `emit_reasoning/emit_metrics`。
- 第二步（下周）：按 TBox 生成字段/关系代号表 `codebook.yaml`，并对 30–50 条核心用例回归。