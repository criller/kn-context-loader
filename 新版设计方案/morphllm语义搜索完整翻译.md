# Grep 还不够：为什么智能体也需要语义搜索

> 原文：https://morphllm.com/blog/semantic-search  
> 作者：Tejas Bhakta  
> 日期：2025年11月6日  
> 阅读时间：5分钟

如何将语义搜索与 grep 结合使用，使智能体在大型代码库上的准确率提升 31%。

## 核心问题

编码智能体在无法找到正确代码时会失败。Grep 适用于精确匹配。但当你的智能体需要理解"我们在哪里处理身份验证？"时，grep 无法返回任何结果。

## 何时使用哪个

**当智能体确切知道要查找什么时使用 grep。**  
模型有很高的置信度。它想要 `getUserById`、`stripe.charges.create`，或匹配 `*Controller.ts` 的文件。Grep 可以立即找到。

**当智能体在探索时使用语义搜索。**  
模型不知道需要什么代码。它问"我们在哪里处理速率限制？"或"JWT 验证是如何工作的？"语义搜索理解意图，无需精确关键词即可找到相关代码。

我们的评估显示，结合两者在所有前沿模型上都是最先进的方法。Grep 用于精确性。语义搜索用于发现。两者结合，平均成功率提升 31%，在大型代码库上提升 56%。

---

Cursor 最近发布的研究显示，语义搜索平均准确率提高 12.5%，在大型代码库上代码保留率提高 2.6%。他们的发现与我们的结果一致：仅使用 grep 是不够的。

Morph SDK 通过一个导入为你提供开箱即用的语义搜索。所有复杂性——Merkle 树、AST 感知分块、自定义嵌入、GPU 重排序——都为你处理好了。

## 工作原理

我们训练了一个自定义嵌入模型，并构建了一个两阶段检索系统：

**阶段 1：向量搜索**（~50ms）  
HNSW 索引从完整代码库中检索 50 个候选结果。

**阶段 2：GPU 重排序**（~150ms）  
morph-rerank-v4 对候选结果进行精确度评分，返回前 10 个。

在 1,000+ 文件的代码库中，总延迟约 1230ms。

## 为什么实现很重要

声称"语义搜索已死"的人通常运行的是低效的实现。

**低效方法：**
* OpenAI text-embedding
* 每 4k token 分块

**正确方法：**
* Merkle 树监控文件变更（只重新嵌入变更的部分）
* AST 感知分块，尊重函数/类边界
* 针对代码特定模式训练的自定义代码嵌入模型
* 使用 HNSW 索引的快速数据库查找
* 全局缓存

区别不在于语义搜索 vs grep。而在于好的语义搜索 vs 差的语义搜索。低效实现会增加延迟而不提高准确性。正确的实现使智能体更快、更准确。

## 结果

我们在 50 个代码库（200-5,000 文件）的 500 个编码任务基准测试上，用三种配置运行智能体：

| 配置 | 成功率 | 平均完成时间 |
|------|--------|--------------|
| 仅 Grep | 64.2% | 38.4s |
| 仅语义搜索 | 71.8% | 35.7s |
| **语义搜索 + Grep** | **84.1%** | **21.2s** |

仅语义搜索比 grep 高 7.6 个百分点。但两者结合比仅使用 grep 高 19.9 个百分点——**提升 31%**。

### 为什么两者都重要

语义搜索缩小到正确的文件。Grep 精确定位这些文件内的确切位置。

**示例工作流：**

1. 智能体问："我们在哪里验证 JWT 令牌？"（语义搜索）
2. 返回 `auth/middleware.ts`、`utils/jwt.ts`
3. 智能体搜索：`function.*verifyToken`（grep）
4. 找到确切实现

这种两阶段方法在我们的评估中，在所有前沿模型上都产生了最好的结果。

## 大型代码库收益更大

在 1,000+ 文件的代码库上，改进更加显著：

| 配置 | 成功率（1,000+ 文件） |
|------|---------------------|
| 仅 Grep | 52.3% |
| 仅语义搜索 | 66.1% |
| **语义搜索 + Grep** | **81.7%** |

这是 **56% 的成功率提升**。代码库越大，语义搜索的帮助越大。Grep 随着代码库规模扩大而表现不佳，因为它依赖于知道要查找什么。语义搜索让智能体能够概念性地探索。

## Morph SDK 如何工作

**1. Push 触发自动索引：**

```typescript
// 代码示例（原文中代码块为空）
```

**2. 使用你首选的 SDK 搜索：**

```typescript
// 代码示例（原文中代码块为空）
```

**3. 使用 Grep 进行后续精确定位：**

一旦语义搜索找到正确的文件，使用 grep 查找确切的符号、导入或调用位置。

## 基于真实智能体行为训练

我们在真实的智能体会话上训练我们的嵌入和重排序模型——使用智能体轨迹来学习实践中"相关"的含义。这反映了 Cursor 的方法：在真实的智能体行为上训练，而不是通用的代码相似性。标准嵌入模型优化相似性。我们的优化任务完成。

## 经验教训

Grep 适用于模型知道要查找什么时。语义搜索适用于需要探索时。两者结合，平均将智能体成功率提升 31%，在大型代码库上提升 56%。

Morph SDK 通过一个导入处理所有复杂性。

`npm install @morphllm/morphsdk` — [文档](https://morphllm.com/docs)

---

## 目录

1. 何时使用哪个
2. 工作原理
3. 为什么实现很重要
4. 结果
5. 大型代码库收益更大
6. Morph SDK 如何工作
7. 基于真实智能体行为训练
8. 经验教训

---

**关于 Morph**

Applied research building for the future of codegen.

© 2025 AutoInfra, Inc. All rights reserved.

Y Combinator 支持

- 文档
- 博客
- 信任中心
- 招聘（我们正在招聘！）

- 隐私政策
- 服务条款
- 服务状态
- 预约通话

