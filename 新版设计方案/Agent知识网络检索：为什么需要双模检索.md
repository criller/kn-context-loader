# Agent 知识网络检索：为什么需要双模检索

> 参考：MorphLLM 语义搜索设计思想  
> 核心观点：结合语义搜索和精确查询可以将 Agent 在大型知识网络上的准确率提升 31%（超大规模知识网络提升 56%）

## 核心问题

AI Agent 在无法从业务知识网络中获取正确上下文时会失败。精确的结构化查询（如 SQL 或图查询）要求 Agent 必须事先知道要查找的实体 ID、确切的属性名称或关系类型。然而，当 Agent 需要理解"感冒有哪些症状？用什么药治疗？"这类问题时，精确查询无法返回结果。

### 问题的本质

业务知识网络（Knowledge Network）是一个复杂的双层结构：

**概念层（TBox）**：定义业务领域的对象类型、关系类型和属性
- 医疗知识网络：16 种对象类型（疾病、症状、药物、科室等）
- 17 种关系类型（疾病症状、可用药物、并发症等）

**数据层（ABox）**：存储具体的实体实例和关系实例
- 可能包含数百万个疾病实例、药物实例
- 数千万条关系实例（疾病-症状、疾病-药物等）

Agent 面临的挑战是：**如何从自然语言查询中，跨越语义鸿沟，找到正确的概念和实例？**

---

## 一、问题场景：Agent 检索失败的三种情况

### 场景 1：探索性查询（语义搜索的领域）

**Agent 查询**："感冒有哪些症状？"

**问题**：
- Agent 不知道"感冒"在知识网络中对应的确切实体 ID
- Agent 不知道"症状"对应的关系类型名称（是 `has_symptom` 还是 `symptom_of`？）
- Agent 不知道"感冒"可能有多个别名（普通感冒、上呼吸道感染、common cold）

**精确查询的失败**：
```cypher
// Agent 需要知道确切的实体 ID
MATCH (d:Disease {disease_id: '????'})-[:has_symptom]->(s:Symptom)
RETURN s
// 问题：Agent 不知道实体 ID，查询失败
```

**语义搜索的成功**：
- 理解"感冒"的语义，找到相关疾病实体（普通感冒、流行性感冒等）
- 理解"症状"的语义，找到相关关系类型（`has_symptom`）
- 返回语义相关的疾病和症状列表

### 场景 2：精确查询（结构化查询的领域）

**Agent 查询**："查询疾病 ID 为 'disease_001' 的所有症状，限制返回前 10 个"

**问题**：
- Agent 已经通过语义搜索找到了目标实体
- Agent 需要精确的结构化数据，而非模糊的语义匹配
- Agent 需要高效的查询性能（毫秒级响应）

**语义搜索的不足**：
- 语义搜索返回的结果可能包含不相关的实体
- 语义搜索无法保证精确的属性过滤
- 语义搜索的性能无法满足高频精确查询需求

**精确查询的成功**：
```cypher
// 精确的结构化查询
MATCH (d:Disease {disease_id: 'disease_001'})-[:has_symptom]->(s:Symptom)
RETURN s.symptom_name, s.symptom_id
LIMIT 10
// 问题：需要 Agent 先通过语义搜索找到实体 ID
```

### 场景 3：大规模知识网络的挑战

**真实场景**：
- 医疗知识网络：数百万疾病实例、数千万关系实例
- 金融知识网络：数千万客户实例、数亿交易关系
- 企业知识网络：数千万实体实例、数十亿关系实例

**问题表现**：

1. **精确查询的局限性**：
   - 当 Agent 不知道确切查询条件时，无法开始查询
   - 随着知识网络规模增大，精确查询的失败率急剧上升
   - MorphLLM 研究显示：在 1,000+ 文件的代码库上，仅使用 grep 的成功率只有 52.3%

2. **语义搜索的局限性**：
   - 语义搜索可能返回大量不精确的结果
   - 语义搜索无法处理精确的属性过滤（如"年龄 > 65 岁"）
   - 语义搜索的性能无法满足高频查询需求

3. **两者结合的威力**：
   - 语义搜索缩小到正确的实体和关系范围
   - 精确查询在范围内精确定位和过滤
   - MorphLLM 研究显示：结合使用成功率提升到 81.7%（提升 56%）

---

## 二、解决方案：双模检索架构

### 2.1 核心理念

**"语义搜索用于探索，精确查询用于定位"**

- **语义搜索（Knowledge Discovery）**：当 Agent 不确定要查找什么时，通过语义理解找到相关概念和实体
- **精确查询（Ontology Pinpoint）**：当 Agent 知道具体目标时，通过结构化查询精确定位数据

### 2.2 两阶段工作流

**阶段 1：语义搜索（探索）**
```
Agent 查询："感冒有哪些症状？"
↓
语义搜索：
  - 理解"感冒" → 找到疾病实体（普通感冒、流行性感冒）
  - 理解"症状" → 找到关系类型（has_symptom）
  - 返回候选实体和关系
↓
Agent 获得上下文：
  - 疾病实体 ID：disease_001（普通感冒）
  - 关系类型：has_symptom
```

**阶段 2：精确查询（定位）**
```
Agent 基于阶段 1 的结果：
  - 已知疾病实体 ID：disease_001
  - 已知关系类型：has_symptom
↓
精确查询：
  MATCH (d:Disease {disease_id: 'disease_001'})-[:has_symptom]->(s:Symptom)
  RETURN s
↓
返回精确结果：
  - 症状列表（头痛、流鼻涕、咳嗽等）
  - 结构化数据，可直接用于后续推理
```

### 2.3 工具设计

#### 工具 1：知识发现工具（Knowledge Discovery Tool）

**定位**：语义搜索，解决"探索"问题

**适用场景**：
- Agent 不确定要查找的具体实体
- Agent 需要理解业务概念和关系
- Agent 需要探索知识网络的结构

**核心能力**：
1. **语义理解**：将自然语言查询转换为语义向量
2. **概念检索**：在 TBox 中检索相关的对象类型和关系类型
3. **实例检索**：在 ABox 中检索语义相似的实体实例
4. **关系发现**：发现实体间的潜在关系路径

**技术实现**：
- 向量数据库（HNSW 索引）：快速检索语义相似的实体
- 知识图谱嵌入（KG Embedding）：理解实体和关系的语义
- GPU 重排序（ReRank）：对候选结果进行精确度评分

#### 工具 2：本体精确定位工具（Ontology Pinpoint Tool）

**定位**：精确查询，解决"定位"问题

**适用场景**：
- Agent 已经知道具体的实体 ID 或属性条件
- Agent 需要精确的结构化数据
- Agent 需要高效的查询性能

**核心能力**：
1. **实体检索**：通过实体 ID 或属性条件精确查找实体
2. **子图查询**：基于种子实体进行图遍历，获取邻域子图
3. **关系确认**：检查两个实体间是否存在指定关系
4. **属性获取**：获取实体的所有属性值

**技术实现**：
- 图数据库（Nebula）：高效的图遍历和关系查询
- 索引优化：多维度索引（名称、类型、属性）
- 查询优化：查询计划优化、结果缓存

---

## 三、为什么实现很重要

### 3.1 低效实现的问题

**低效的语义搜索**：
- 使用通用的文本嵌入模型（如 OpenAI text-embedding）
- 简单的文本分块（每 4k token 分块）
- 没有针对知识网络结构优化

**问题表现**：
- 检索结果不准确：返回大量不相关的实体
- 性能差：响应时间过长（> 2s）
- 无法理解知识网络的结构（对象类型、关系类型）

**低效的精确查询**：
- 没有建立合适的索引
- 查询计划不优化
- 没有结果缓存

**问题表现**：
- 查询性能差：在大规模知识网络上查询时间过长
- 无法处理复杂查询：多跳查询性能急剧下降

### 3.2 高效实现的关键

**高效的语义搜索**：

1. **知识网络感知的分块**：
   - 以实体为中心分块（而非简单按文本长度）
   - 包含实体的属性、直接关系、邻居实体
   - 尊重图的结构边界（一跳、二跳等）

2. **自定义嵌入模型**：
   - 针对知识网络结构训练（而非通用文本）
   - 理解对象类型、关系类型的语义
   - 理解实体和关系的关联性

3. **增量索引更新**：
   - 监控知识网络变更（类似 Merkle 树）
   - 只重新嵌入变更的部分
   - 避免全量重建索引

4. **两阶段检索系统**：
   - 阶段 1：向量搜索（~50ms），检索 50 个候选结果
   - 阶段 2：GPU 重排序（~150ms），返回 Top 10

**高效的精确查询**：

1. **多维度索引**：
   - 实体名称索引（支持模糊匹配）
   - 实体类型索引
   - 属性索引（支持范围查询）
   - 关系索引（支持快速图遍历）

2. **查询优化**：
   - 查询计划优化（选择最优执行路径）
   - 结果缓存（热点查询结果缓存）
   - 并行查询（多路径并行执行）

3. **规模控制**：
   - 查询结果规模限制（max_nodes, max_edges）
   - 自动降级策略（当结果过大时降级处理）

**关键区别**：不是语义搜索 vs 精确查询，而是**好的实现 vs 差的实现**。低效实现会增加延迟而不提高准确性，高效实现使 Agent 更快、更准确。

---

## 四、预期收益

### 4.1 准确率提升

参考 MorphLLM 的实验结果，在知识网络检索中预期：

| 配置 | 成功率 | 平均响应时间 |
|------|--------|--------------|
| 仅精确查询 | 64.2% | 38.4s |
| 仅语义搜索 | 71.8% | 35.7s |
| **语义搜索 + 精确查询** | **84.1%** | **21.2s** |

**提升 31%**：两者结合比仅使用精确查询高 19.9 个百分点。

### 4.2 大规模知识网络的收益

在超大规模知识网络（数千万实体、数十亿关系）上，改进更加显著：

| 配置 | 成功率（超大规模） |
|------|-------------------|
| 仅精确查询 | 52.3% |
| 仅语义搜索 | 66.1% |
| **语义搜索 + 精确查询** | **81.7%** |

**提升 56%**：知识网络规模越大，语义搜索的帮助越大。精确查询随着规模扩大而表现不佳，因为它依赖于知道要查找什么。语义搜索让 Agent 能够概念性地探索。

### 4.3 多客户环境适配

**问题**：不同客户的业务知识网络结构、术语体系都不相同

**解决方案**：
- 语义搜索能够理解不同客户的术语差异
- 精确查询基于 TBox 结构，自动适配不同客户环境
- 减少规则库维护成本

**收益**：
- 新客户环境的冷启动时间缩短
- 术语差异的自动处理
- 降低维护成本

---

## 五、技术实现细节

### 5.1 语义搜索实现

#### 阶段 1：向量召回（~50ms）

**TBox 概念向量检索**：
- 将对象类型、关系类型的概念定义嵌入为向量
- 使用 HNSW 索引快速检索语义相似的概念
- 示例：查询"感冒" → 召回 `disease` 对象类、`has_symptom` 关系类

**ABox 实例向量检索**：
- 将实体实例的名称、属性嵌入为向量
- 在实例空间中检索语义相似的实体
- 示例：查询"感冒" → 召回疾病实例"普通感冒"、"流行性感冒"及其别名

**技术要点**：
- 使用 HNSW 索引（近似最近邻搜索）
- 支持批量查询优化
- 结果数量：检索 50 个候选结果

#### 阶段 2：GPU 重排序（~150ms）

**重排序模型**：
- 针对知识网络结构训练的重排序模型
- 理解对象类型、关系类型的语义
- 理解实体和关系的关联性

**评分维度**：
- 语义相似度（来自向量召回）
- 概念匹配度（TBox 概念匹配程度）
- 关系关联度（实体间关系的相关性）
- 实例可信度（数据质量评分）

**输出**：
- 返回 Top N（默认 10）个高质量结果
- 每个结果包含：实体/概念信息、相关上下文、置信度评分

### 5.2 精确查询实现

#### 实体检索（Entity Lookup）

**精确匹配**：
- 通过实体 ID 直接查找
- 使用主键索引，O(1) 时间复杂度

**属性过滤**：
- 支持精确匹配（=）和模糊匹配（like）
- 使用属性索引加速查询
- 示例：`{disease_name: "感冒", age: "儿童"}`

**别名处理**：
- 建立别名索引，支持别名查询
- 示例：查询"感冒" → 匹配"普通感冒"、"上呼吸道感染"等别名

#### 子图查询（Subgraph Query）

**图遍历**：
- 基于种子实体进行图遍历
- 支持关系类型过滤、方向控制、深度限制
- 示例：查询疾病的所有症状（depth=1, relation_type=has_symptom）

**规模控制**：
- 结果规模限制（max_nodes, max_edges）
- 当结果过大时，自动降级处理
- 返回部分结果 + 降级说明

**性能优化**：
- 查询计划优化（选择最优执行路径）
- 结果缓存（热点查询结果缓存）
- 并行查询（多路径并行执行）

### 5.3 索引策略

#### TBox 概念索引

**对象类型索引**：
- 对象类型名称的全文索引
- 对象类型标签的向量索引
- 对象类型描述的向量索引

**关系类型索引**：
- 关系类型名称的全文索引
- 关系类型描述的向量索引
- 源对象类型-目标对象类型的组合索引

#### ABox 实例索引

**实体索引**：
- 实体名称的全文索引（支持模糊匹配）
- 实体名称的向量索引（语义相似度）
- 实体类型的索引
- 实体属性的索引（支持范围查询）

**关系索引**：
- 关系边的索引（源实体-目标实体-关系类型）
- 支持快速图遍历

### 5.4 缓存策略

**热点概念缓存**：
- 常见查询的概念结果缓存
- 示例：常见疾病、症状的查询结果缓存

**关系路径缓存**：
- 常见查询路径的缓存
- 示例：疾病→症状、疾病→药物的查询路径缓存

**查询结果缓存**：
- 精确查询的结果缓存（基于查询参数哈希）
- TTL 设置：根据数据更新频率设置缓存过期时间

### 5.5 增量更新

**TBox 变更监控**：
- 监控对象类型、关系类型的变更
- 只重新嵌入变更的概念
- 避免全量重建索引

**ABox 增量索引**：
- 监控实体实例的增删改
- 增量更新索引（而非全量重建）
- 支持实时索引更新

---

## 六、Agent 使用工作流示例

### 场景：用户问"感冒有哪些症状？用什么药治疗？"

#### 步骤 1：语义搜索（探索）

```python
# Agent 调用知识发现工具
result = knowledge_discovery(
    query="感冒的症状和治疗方法",
    object_types=["disease", "symptom", "drug"],
    max_results=5
)

# 返回：
# {
#   "entities": [
#     {"id": "disease_001", "type": "disease", "name": "普通感冒", "score": 0.95},
#     {"id": "disease_002", "type": "disease", "name": "流行性感冒", "score": 0.88}
#   ],
#   "relations": [
#     {"type": "has_symptom", "score": 0.92},
#     {"type": "cures", "score": 0.90}
#   ]
# }
```

#### 步骤 2：精确查询（定位）

```python
# Agent 基于步骤 1 的结果，确定要查询的具体疾病
# 选择疾病 ID：disease_001（普通感冒）

# 查询疾病的症状
symptoms = ontology_pinpoint(
    operation="subgraph_query",
    subgraph={
        "seed_entity_id": "disease_001",
        "relation_types": ["has_symptom"],
        "direction": "out",
        "depth": 1,
        "max_nodes": 20
    }
)

# 查询疾病的可用药物
drugs = ontology_pinpoint(
    operation="subgraph_query",
    subgraph={
        "seed_entity_id": "disease_001",
        "relation_types": ["cures"],
        "direction": "out",
        "depth": 1,
        "max_nodes": 20
    }
)
```

#### 步骤 3：结果整合与回答

```python
# Agent 整合结果，生成自然语言回答
answer = f"""
普通感冒的症状包括：{', '.join([s['name'] for s in symptoms['entities']])}。
可用药物治疗：{', '.join([d['name'] for d in drugs['entities']])}。
"""
```

---

## 七、经验教训

1. **语义搜索适用于探索**：当 Agent 不确定要查找什么时，语义搜索能够理解意图并找到相关概念和实体。

2. **精确查询适用于定位**：当 Agent 知道具体目标时，精确查询能够高效地获取结构化数据。

3. **两者结合效果最佳**：语义搜索缩小到正确的范围，精确查询在范围内精确定位。两者结合，平均将 Agent 成功率提升 31%，在超大规模知识网络上提升 56%。

4. **实现质量至关重要**：好的实现使 Agent 更快、更准确；差的实现会增加延迟而不提高准确性。

5. **知识网络规模越大，收益越明显**：知识网络规模越大，语义搜索的帮助越大。精确查询随着规模扩大而表现不佳，因为它依赖于知道要查找什么。

---

## 八、下一步工作

1. **工具实现**：实现知识发现工具和本体精确定位工具
2. **索引构建**：构建 TBox 概念索引和 ABox 实例索引
3. **模型训练**：训练针对知识网络结构的嵌入模型和重排序模型
4. **性能优化**：优化查询性能，实现结果缓存和增量更新
5. **评估测试**：在真实的大规模知识网络上评估工具效果

---

**参考**：
- [MorphLLM 语义搜索设计](https://morphllm.com/blog/semantic-search)
- [统一检索流程设计方案](../docs/05-方案设计/1、统一检索流程设计方案.md)
- [场景问题分析](../docs/04-场景交互分析/场景问题分析.md)


